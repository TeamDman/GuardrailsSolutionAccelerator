# pipeline for development/testing release publishing in forks

trigger: none

parameters:
  - name: 'signCode'
    type: boolean
    default: 'true'
  - name: 'testDeployment'
    type: boolean
    default: 'true'
  - name: 'publishGitHubRelease'
    type: boolean
    default: 'true'
  - name: 'testDeploymentSubscriptionConnectionName'
    type: string
    default: 'Matthew Virtual Studio (mb_co)'

pool:
  vmImage: windows-latest

variables: 
  - group: 'GuardrailsTestDeployments'

steps:

- task: EsrpCodeSigning@1
  inputs:
    ConnectedServiceName: 'ESRP Guardrails Accelerator Signing'
    FolderPath: './'
    Pattern: '*ps*'
    signConfigType: 'inlineSignParams'
    inlineOperation: |
        [{
            "KeyCode" : "CP-230012",
            "OperationCode" : "SigntoolSign",
            "Parameters" : {
                "OpusName" : "Microsoft",
                "OpusInfo" : "http://www.microsoft.com",
                "FileDigest" : "/fd \"SHA256\"",
                "PageHash" : "/NPH",
                "TimeStamp" : "/tr \"http://rfc3161.gtm.corp.microsoft.com/TSS/HttpTspServer\" /td sha256"
            },
            "ToolName" : "sign",
            "ToolVersion" : "1.0"
        },
        {
            "KeyCode" : "CP-230012",
            "OperationCode" : "SigntoolVerify",
            "Parameters" : {},
            "ToolName" : "sign",
            "ToolVersion" : "1.0"
        }]
    SessionTimeout: '60'
    MaxConcurrency: '50'
    MaxRetryAttempts: '5'
  enabled: true
  condition: ${{ if eq(parameters.signCode, true)}}

#look for hash mismatch
- powershell: |
    $signatureStatuses = Get-ChildItem -r -i *.ps* | Get-AuthenticodeSignature

    Foreach ($signatureStatus in $signatureStatuses) {
      If ($signatureStatus.Status -eq 'HashMismatch') {
        throw "File '$($signatureStatus.Path)' has a hash status of '$($signatureStatus.status)'"
      }
      ElseIf ($signatureStatus.Status -eq 'NotSigned') {
        Write-Warning "File '$($signatureStatus.Path)' has a hash status of '$($signatureStatus.status)'"
      }
      ElseIf ($signatureStatus.Status -eq 'Valid') {
        Write-Host "File '$($signatureStatus.Path)' has a hash status of '$($signatureStatus.status)'"
      }
      Else {
        throw "File '$($signatureStatus.Path)' has an unhandled hash status of '$($signatureStatus.status)'"
      }
    }
  name: CheckForSignFailures
  condition: ${{ if eq(parameters.signCode, true)}}

#test module imports
- powershell: |
    $ErrorActionPreference = 'Stop'

    $moduleFiles = Get-ChildItem -path ./* -recurse -include *.psm1
    Write-Host "Count of module files: $($moduleFiles.count)"
    
    try {
      ForEach ($moduleFile in $moduleFiles) {
        Import-Module $moduleFile.Fullname -ErrorAction Stop
      }
    }
    catch {
      throw "Failed test import module '$moduleFile' with error: $_"
    }

    $importedModules = Get-Module
    Write-Host "Imported modules: `n $($importedModules.Path | Out-String)"

    $missingModules = $moduleFiles | Where-object {$_ -inotin ($importedModules).Path} 
    If ($missingModules) {
      throw "The following modules failed import test: $missingModules"
    }
  name: TestModuleImports
  condition: ${{ if eq(parameters.signCode, true)}}

- task: AzurePowerShell@5
  inputs:
    azureSubscription: ${{ parameters.testDeploymentSubscriptionConnectionName }}
    ScriptType: 'InlineScript'
    FailOnStandardError: true
    azurePowerShellVersion: 'LatestVersion'
    pwsh: true
    Inline: |
      If (Get-AzResourceGroup -Name 'guardrails-$guardrailsResourceSuffix' -ErrorAction 'SilentlyContinue') {
        throw "The test deployment action cannot continue because resource group 'guardrails-$guardrailsResourceSuffix' already exists in subscription '$((get-azcontext).Subscription.Name)'; clean up the test subscription before proceeding."
      }

      $configFilePath = Join-Path -Path $env:AGENT_TEMPDIRECTORY -ChildPath 'config.json'

      $configContent = @'
      {
          "keyVaultName": "guardrails",
          "resourcegroup": "Guardrails",
          "region": "CanadaCentral",
          "storageaccountName": "guardrail",
          "logAnalyticsworkspaceName": "guardrails",
          "autoMationAccountName": "guardrails",
          "FirstBreakGlassAccountUPN": "breakglass1@$(testTenantDomain)",
          "SecondBreakGlassAccountUPN": "breakglass2@$(testTenantDomain)",
          "PBMMPolicyID": "4c4a5f27-de81-430b-b4e5-9cbd50595a87",
          "AllowedLocationPolicyId": "e56962a6-4747-49cd-b67b-bf8b01975c4c",
          "DepartmentNumber": "",
          "CBSSubscriptionName": "$(CBSSubscriptionName)",
          "SecurityLAWResourceId": "/subscriptions/$(testSubscriptionId)/resourceGroups/rg-core/providers/Microsoft.OperationalInsights/workspaces/mtb-law01",
          "HealthLAWResourceId": "/subscriptions/$(testSubscriptionId)/resourceGroups/rg-core/providers/Microsoft.OperationalInsights/workspaces/mtb-law01",
          "Locale": "en-CA",
          "lighthouseServiceProviderTenantID": "$(lighthouseProviderTenantId)",
          "lighthousePrincipalDisplayName": "$(lighthousePrincipalDisplayName)",
          "lighthousePrincipalId": "$(lighthousePrincipalId)",
          "lighthouseTargetManagementGroupID": "mb_co"
        }
      '@
      Set-Content -Path $configFilePath -Value $configContent

      $userId = '$(testUserId)@$(testTenantDomain)'
      $alternatePSModulesURL = "{0}/raw/{1}/psmodules" -f $env:BUILD_REPOSITORY_URI,$env:BUILD_SOURCEBRANCHNAME
      Write-Output "alternatePSModulesURL is '$alternatePSModulesURL'"

      Push-Location -Path setup

      try {
          $ErrorActionPreference = 'Stop'
          ./setup.ps1 -configFilePath $configFilePath -configureLighthouseAccessDelegation -alternatePSModulesURL $alternatePSModulesURL -Verbose
      }
      catch {
          throw "Failed test deploy of solution with error: $_"
      }
      finally {
        If (!$?) {throw "Failed test deploy of solution with error: $($error[0]) $_"}
      }
  name: 'TestSolutionDeploy'
  condition: ${{ if eq(parameters.testDeployment, true)}}

- task: AzurePowerShell@5
  condition: and(always(),${{ if eq(parameters.testDeployment, true)}})
  inputs:
    azureSubscription: ${{ parameters.testDeploymentSubscriptionConnectionName }}
    ScriptType: 'InlineScript'
    FailOnStandardError: true
    azurePowerShellVersion: 'LatestVersion'
    pwsh: true
    Inline: |
      $guardrailsResourceSuffix = (Get-AzContext).Tenant.id.Split("-")[0]

      If (get-azresource -ResourceId "/subscriptions/$(testSubscriptionId)/resourceGroups/Guardrails-$guardrailsResourceSuffix/providers/Microsoft.OperationalInsights/workspaces/guardrails-$guardrailsResourceSuffix" -ErrorAction SilentlyContinue) {
        Write-Verbose "Force deleting Log Analytics Workspace..."
        get-azresource -ResourceId "/subscriptions/$(testSubscriptionId)/resourceGroups/Guardrails-$guardrailsResourceSuffix/providers/Microsoft.OperationalInsights/workspaces/guardrails-$guardrailsResourceSuffix" | 
          get-AzOperationalInsightsWorkspace  | 
          Remove-AzOperationalInsightsWorkspace -Force -ForceDelete
      } 

      If (Get-AzResourcegroup -Id "/subscriptions/$(testSubscriptionId)/resourceGroups/Guardrails-$guardrailsResourceSuffix" -ErrorAction SilentlyContinue) {
        Write-Verbose "Deleteting resource group (async)..."
        Remove-AzResourceGroup -Id "/subscriptions/$(testSubscriptionId)/resourceGroups/Guardrails-$guardrailsResourceSuffix" -force -AsJob | Out-Null # don't wait for delete to complete
      }

      #remove lighthouse assignments
      Write-Verbose "Checking for Lighthouse assignments..."
      $uri = 'https://management.azure.com/subscriptions/{0}/providers/Microsoft.ManagedServices/registrationAssignments?api-version=2022-01-01-preview' -f '$(testSubscriptionId)'
      $assignments = Invoke-AzRestMethod -Method GET -Uri $uri -Verbose
      $assignmentValue = $assignments.Content | ConvertFrom-Json

      ForEach ($assignment in $assignmentValue) {
          If ($assignment.Value.name) {
            Write-Verbose "Deleteing lighthouse assignment '$($assignment.name)'"
            $uri = 'https://management.azure.com/subscriptions/{0}/providers/Microsoft.ManagedServices/registrationAssignments/{1}?api-version=2022-01-01-preview' -f '$(testSubscriptionId)',$assignment.value.Name

            Invoke-AzRestMethod -Method DELETE -Uri $uri -Verbose
          }
      }

      #remove lighthouse definitions
      Write-Verbose "Checking for lighthouse registration definitions..."
      $uri = 'https://management.azure.com/subscriptions/{0}/providers/Microsoft.ManagedServices/registrationdefinitions?api-version=2022-01-01-preview' -f '$(testSubscriptionId)'
      $definitions = Invoke-AzRestMethod -Method GET -Uri $uri
      $definitionsValue = $definitions.Content | ConvertFrom-Json

      ForEach ($definition in $definitionsValue.value) {
          if ($definition.name) {
          Write-Verbose "Deleteing lighthouse registration definition '$($definition.Name)'"
          $uri = 'https://management.azure.com/subscriptions/{0}/providers/Microsoft.ManagedServices/registrationdefinitions/{1}?api-version=2022-01-01-preview' -f '$(testSubscriptionId)',$definition.Name

          Invoke-AzRestMethod -Method DELETE -Uri $uri -Verbose
          }
      }

      $lighthouseTargetManagementGroupID = 'mb_co'
      If ($lighthouseTargetManagementGroupID -eq (Get-AzContext).Tenant.Id) {
          $assignmentScopeMgmtmGroupId = '/'
      }
      Else {
          $assignmentScopeMgmtmGroupId = $lighthouseTargetManagementGroupID
      }

      # check if a lighthouse defender for cloud policy MSI role assignment already exists - assignment name always 2cb8e1b1-fcf1-439e-bab7-b1b8b008c294 
      Write-Verbose "Checking for role assignments at management group '$assignmentScopeMgmtmGroupId' for role 'Owner'"
      $uri = 'https://management.azure.com/providers/Microsoft.Management/managementGroups/{0}/providers/Microsoft.Authorization/roleAssignments/{1}?&api-version=2018-01-01-preview' -f $lighthouseTargetManagementGroupID,'2cb8e1b1-fcf1-439e-bab7-b1b8b008c294'
      $roleAssignments = Invoke-AzRestMethod -Uri $uri -Method GET -Verbose | Select-Object -Expand Content | ConvertFrom-Json
      If ($roleAssignments.id) {
          Write-Verbose "Deleteing role assignments '$roleAssignments'"
          $uri = 'https://management.azure.com/{0}?api-version=2015-07-01' -f $roleAssignments.id
          Invoke-AzRestMethod -Uri $uri -Method DELETE -Verbose
      }
      Else {
          Write-Verbose "No DfC role assignments found..."
      }

      
      # check if a lighthouse Azure Automation MSI role assignment to register the Lighthouse resource provider already exists - assignment name always  5de3f84b-8866-4432-8811-24859ccf8146
      Write-Verbose "Checking for role assignments at management group '$assignmentScopeMgmtmGroupId' for role 'Custom-RegisterLighthouseResourceProvider'"
      $uri = 'https://management.azure.com/providers/Microsoft.Management/managementGroups/{0}/providers/Microsoft.Authorization/roleAssignments/{1}?&api-version=2018-01-01-preview' -f $lighthouseTargetManagementGroupID, '5de3f84b-8866-4432-8811-24859ccf8146'
      $roleAssignments = Invoke-AzRestMethod -Uri $uri -Method GET | Select-Object -Expand Content | ConvertFrom-Json   
      If ($roleAssignments.id) { 
          Write-Verbose "Deleteing role assignments '$roleAssignments'"
          $uri = 'https://management.azure.com/{0}?api-version=2015-07-01' -f $roleAssignments.id
          Invoke-AzRestMethod -Uri $uri -Method DELETE -verbose
      }
      else {
          Write-Verbose "No MSI role assignemnts found"
      }

      # check if lighthouse Custom-RegisterLighthouseResourceProvider exists at a different scope
      Write-Verbose "Checking for existing role definitions with name 'Custom-RegisterLighthouseResourceProvider'"
      $uri = "https://management.azure.com/providers/Microsoft.Management/managementGroups/{0}/providers/Microsoft.Authorization/roleDefinitions?`$filter=roleName eq '{1}'&api-version=2018-01-01-preview" -f $lighthouseTargetManagementGroupID,'Custom-RegisterLighthouseResourceProvider'
      $response = Invoke-AzRestMethod -Uri $uri -Method Get

      If ($response.StatusCode -eq '200') {
          If ($roleDefId = ($response.Content | ConvertFrom-Json).Name) {
          $uri = 'https://management.azure.com/providers/Microsoft.Management/managementGroups/{0}/providers/Microsoft.Authorization/roleDefinitions/{1}?api-version=2018-01-01-preview' -f $lighthouseTargetManagementGroupID,$roleDefId

          Invoke-AzRestMethod -Method DELETE -Uri $uri
          }
      }
  name: 'CleanUpTest'
  displayName: 'Clean up deployment test environment'


- powershell: |
    $dest = "{0}/{1}.zip" -f $ENV:BUILD_ARTIFACTSTAGINGDIRECTORY,(get-date -f 'yyyy-MM-dd-HH-mm-ss')
    Compress-Archive -Path ./* -DestinationPath $ENV:BUILD_ARTIFACTSTAGINGDIRECTORY/$(get-date -f 'yyyy-MM-dd-HH-mm-ss').zip
  name: 'zipartifact'

- task: PublishBuildArtifacts@1
  inputs:
    PathtoPublish: '$(Build.ArtifactStagingDirectory)'
    ArtifactName: 'drop'
    publishLocation: 'Container'

- task: GitHubRelease@1
  displayName: 'Publish release files to GitHub'
  inputs:
    gitHubConnection: 'mbrat2005'
    repositoryName: '$(Build.Repository.Name)'
    action: 'create'
    target: '$(Build.SourceVersion)'
    tag: 'test-release'
    assets: 'psmodules/*'
    changeLogCompareToRelease: 'lastFullRelease'
    changeLogType: 'commitBased'
    isDraft: true
  condition: ${{ if eq(parameters.publishGitHubRelease, true)}}